.. _cega_lega:

Connection CEGA |connect| LEGA
==============================

All Local EGA instances are connected to Central EGA using `AMQP, the
advanced message queueing protocol <http://www.amqp.org/>`_, that
allows application components to send and receive messages. Messages
are queued, not lost, and resend on network failure or connection
problems. Naturally, this is configurable.


In practice, the `reference implementation
<https://github.com/EGA-archive/LocalEGA/tree/master/ingestion/mq>`_
uses the RabbitMQ message broker for each LocalEGA, henceforth called
*local broker*, which is the **only** component with the necessary
credentials to connect to the Central EGA message broker, henceforth
called *central broker*. The other LocalEGA components are connected
to their respective local broker.

.. note:: We pinned the RabbitMQ version to ``3.7.8``, so far, until
          both CegaMQ and LegaMQ can be upgraded simultaneously to the
          latest version.


For each LocalEGA instance, the central broker configures a ``vhost``,
and creates the credentials to connect to that ``vhost`` in the form
of a *username/password* pair. The local brokers then use a connection
string with the following syntax:

.. code-block:: console

   amqps://<user>:<password>@<cega-host>:<port>/<vhost>


.. image:: /static/amqp.png
   :target: ./_static/amqp.png
   :alt: RabbitMQ setup

The connection is a two-way connection using a combination of a
*federated queue* and a *shovel*.

The local broker registers a *federated queue* with the central broker
as *upstream*, named ``v1.files``, and listens to the incoming
messages. In order to minimize the number of connection sockets, all
Local EGAs only use *one* federated queue towards the central broker,
and all messages in the queue are distinguished with a ``type``.

Ingestion workers listen to the downstream queue of the local
broker. If there are no messages to work on, the local broker will ask
its upstream queue if it has messages. If so, messages are moved
downstream. If not, ingestion workers wait for messages to arrive.

.. note:: This allows a Local EGA instance to *also* ingest files from
   other sources than Central EGA. For example, a message, external to
   Central EGA, could be dropped in the local broker in order to
   ingest non-EGA files.


The central broker receives notifications from the local broker using
a *shovel*. The local broker has an exchange named ``cega`` configured
such that all messages published to it get forwarded to CentralEGA
(using the same routing key). This is how we propagate the different
status of the workflow to the central broker, using the following
routing keys:

* ``files.verified`` for properly ingested files, ready to request an Accession ID.
* ``files.completed`` for properly backed-up files, ready to be distributed
* ``files.error`` for user-related errors
* ``files.inbox`` for inbox file operations

The shovel is backed by a ``to_cega`` is case *CegaMQ* is temporarily
unavailable. This is similar to a (reverse) federated queue.


Message interface (API)
=======================

It is necessary to agree on the format of the messages exchanged
between Central EGA and any Local EGAs. All messages are
JSON-formatted.


Inbox to Central EGA
--------------------

The messages sent by the inbox hooks capture when a file is (re)uploaded, renamed or removed. 

For a file upload:

.. code::

		{
                                 "user": <str>,
                             "filepath": <str>,
                            "operation": "upload",
                             "filesize": <num>,
                   "file_last_modified": <num>, // a UNIX timestamp
                  "encrypted_checksums": [{ "type": <str>, "value": <checksum as HEX> },
                                          { "type": <str>, "value": <checksum as HEX> },
					  ...
					  ]
		}

The checksum algorithm type is "md5", or "sha256".
"sha256" is preferred.

For a file removal:

.. code::

		{
                                 "user": <str>,
                             "filepath": <str>,
                            "operation": "remove",
		}

For a file renaming:

.. code::

		{
                                 "user": <str>,
                             "filepath": <str>,
                              "oldpath": <str>,
                            "operation": "rename",
		}

The message headers include:

- a content type: ``application/json``
- delivery mode: 2 (for persistence)
- and a correlation id.

The correlation id is a uuid of 37 characters, generated by `uuid_generate <https://linux.die.net/man/3/uuid_generate>`_.


From Central EGA to Local EGA
-----------------------------

In order to distinguish message, Central EGA adds a field named
``type`` to all outgoing messages. There are 4 types of messages so
far:

* ``type=ingest``: an ingestion trigger
* ``type=accession``: contains an accession id
* ``type=mapping``: contains a dataset to accession id mapping (they
  are known a the metadata release stage or when permissions are
  granted by a DAC
* ``type=heartbeat``: A mean to check if the Local EGA instance is "alive"

From Local EGA to Central EGA
-----------------------------

.. note:: To be finished.


.. |connect| unicode:: U+21cc .. <->
.. _RabbitMQ: http://www.rabbitmq.com
